#!/usr/bin/php
<?php
// Record start time
inform("Starting $argv[0] at " . timestamp());

require("Archive.class.php");
// error_reporting(E_ERROR);
define("DEBUG", false);
$config_dir = "/etc/backup";
//$config_dir = ".";
$config_file = $config_dir . "/backup.conf";
$files = []; // Array of files to back up
$archive = ""; // Filename of backup
$class_archive = new Archive();

debug("Including $config_file");
if (is_readable($config_file)) {
	include_once $config_file;
	$files[] = $backup_conf['tmp_dir'];
} else {
	die ("Can't read configuration file\n");
}

init();
main();
housekeeping();

inform("Ending $argv[0] at " . timestamp());

function init()
{
	global $backup_conf;

	global $class_archive;
	$class_archive->set_debug(DEBUG);

	foreach ([$backup_conf['dst_dir'], $backup_conf['tmp_dir']] as $dir) {
		// Verify directory exists
		if (is_dir($dir)) {
    		// Verify directory is writable
			if (opendir($dir)) {
				// write dummy file to verify we've got write access
				$filename = "$dir/" . timestamp();
				if (!fopen($filename, "w")) {
					die('Can\'t write to directory ' . $dir);
				} else {
					// All ok, remove file again
					unlink($filename);
				}
			} else {
				die('Can\'t open directory ' . $dir);
			}
		} elseif (mkdir($dir, 0777, true)) {
			debug("Created directory $dir");
		}
	}
}

function main()
{
	global $backup_mysql, $backup_conf;
//	package_info();

	if (isset($backup_conf['retain'])) {
		remove_old();
	}

	if (count($backup_mysql['databases']) > 0) {
		mysql_db_size();
		backup_mysql();
	}

	backup_data();

	if ($backup_conf['store_remote']) {
		store_remote();
	}
}

function package_info()
{
	$packages_cmd     = "dpkg --get-selections | cut -f1 ";
	$single_line_cmd  = sprintf("%s | tr '\\012' ' '", $packages_cmd);
	$md5_cmd          = sprintf("%s | md5sum | cut -f1 -d ' '", $single_line_cmd);
	$num_packages_cmd = sprintf("%s | wc -l", $packages_cmd);
	debug(sprintf("\$packages_cmd: %s", $packages_cmd));
	debug(sprintf("\$single_line_cmd: %s", $single_line_cmd));
	debug(sprintf("\$md5_cmd: %s", $md5_cmd));
	debug(sprintf("\$num_packages_cmd: %s", $num_packages_cmd));

	exec($num_packages_cmd, $output, $retval);
	inform(sprintf("Number of packages installed: %d", $output[0]));
	unset($output);

	inform("md5sum of list of installed packages: ", false);
	exec($md5_cmd, $output, $retval);
	inform("$output[0]");
	unset($output);

	inform("List of installed packages:");
	exec($single_line_cmd, $output, $retval);
	inform("$output[0]");
	unset($output);
}

function housekeeping()
{
	global $backup_conf, $files;

	if (!$backup_conf['tmp_dir'] == "/tmp") {
		delete_recursive($backup_conf['tmp_dir'] . "/");
	}
}

function encrypt()
{
	global $archive, $backup_conf;

	$cmd = sprintf("gpg --encrypt -r %s --output %s.gpg %s && rm %s", $backup_conf['pgp_recipient'], $archive, $archive, $archive);
	debug(sprintf("\$cmd: %s", $cmd));
	exec($cmd, $output, $retval);
	if ($retval == 0) {
		inform(sprintf("Archive encrypted for: %s", $backup_conf['pgp_recipient']));
		$archive = sprintf("%s.gpg", $archive);
	} else {
		inform("Error $retval:");
		foreach ($output as $line) {
			inform("$line");
		}
	}
}

function mysql_db_size()
{
	global $backup_mysql, $backup_conf;

	$lbl_db = "Database Name";
	$lbl_size_bytes = "Size in Bytes";
	$lbl_size_mib = "Size in MiB";
	$query = sprintf("SELECT
  table_schema '%s',
  SUM(data_length + index_length) '%s',
  ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) '%s'
FROM information_schema.tables
GROUP BY table_schema;", $lbl_db, $lbl_size_bytes, $lbl_size_mib);

	$conn = new mysqli($backup_mysql['hostname'], $backup_mysql['username'], $backup_mysql['password']);
	if ($conn->connect_error) {
		die("MySQLi connection failed: " . $conn->connect_error);
	} else {
		$result = $conn->query($query);
		inform(sprintf("\n%1$- 30s | %2$ 15s | %3$ 15s", $lbl_db, $lbl_size_bytes, $lbl_size_mib));
		inform(sprintf("%1$'-30s-+-%1$'-15s-+-%1$'-15s", "-"));
		while($row = $result->fetch_assoc()) {
			inform(sprintf("%1$- 30s | %2$ 15d | %3$ 15.2f", $row[$lbl_db], $row[$lbl_size_bytes], $row[$lbl_size_mib]));
		}
		$conn->close();
		inform("");
	}
}

function backup_mysql()
{
	global $backup_mysql, $backup_conf;

	foreach ($backup_mysql['databases'] as $db) {
		if (isset($db)) {
			inform("Starting backup of mysql database '$db'");
			$filename =
				$backup_conf['tmp_dir'] .
				"/" .
				"$db-" .
				timestamp("Ymd") .
				".sql";
			$cmd = "mysqldump --host=";
			$cmd .= $backup_mysql['hostname'];
			$cmd .= " --user=";
			$cmd .= $backup_mysql['username'];
			$cmd .= " --password='";
			$cmd .= $backup_mysql['password'];
			$cmd .= "' ";
			$cmd .= $backup_mysql['options'];
			$cmd .= " --databases $db";
			$cmd .= " > $filename";
			debug(sprintf("\$mc = %s", $cmd));

			exec("$cmd 2>1", $output, $retval);

			if ($retval == 0) {
				$chown_cmd = "chown {$backup_conf['luser']}:{$backup_conf['lgroup']} $filename";
				exec($chown_cmd, $output, $retval);
				inform("Finished backup of mysql database '$db'");
			} else {
				inform("Error $retval:");
				foreach ($output as $line) {
					inform("$line");
				}
				unlink($filename);
				// exit($retval);
			}
		}
	}
}

function copy_recursive($source_dir = "", $dest_dir = "")
{
	$error = 0;
	$file_list = [];

	if ($source_dir == "") {
		inform("ERROR: copy_recursive: \$source_dir is empty");
		$error = 1;
	} elseif ($dest_dir == "") {
		inform("ERROR: copy_recursive: \$dest_dir is empty");
		$error = 2;
	} elseif (!is_readable($source_dir)) {
		inform("ERROR: copy_recursive: \$source_dir is not readable");
		$error = 3;
	} elseif (!is_writable($dest_dir)) {
		inform("ERROR: copy_recursive: \$dest_dir is not writable");
		$error = 4;
	}

	if ($error === 0) {
		$contents = scandir($source_dir);
		for ($i = 2; $i < count($contents); $i++) {
			if (is_dir($source_dir . "/" . $contents[$i])) {
				mkdir($dest_dir . "/" . $contents[$i]);
				$copied_files = copy_recursive(
					$source_dir . "/" . $contents[$i],
					$dest_dir . "/" . $contents[$i]
				);
				foreach ($copied_files as $copied_file) {
					$file_list[] = $copied_file;
				}
			} else {
				debug(sprintf("copy_recursive: copying %s/%s to %s", $source_dir, $contents[$i], $dest_dir));
				copy(
					$source_dir . "/" . $contents[$i],
					$dest_dir . "/" . $contents[$i]
				);
				$file_list[] = $dest_dir . "/" . $contents[$i];
			}
		}
	} else {
		debug(sprintf("copy_recursive: not copying due to error %s", $error));
	}

	debug(sprintf("copy_recursive: \$file_list contains %d items", count($file_list)));
	return $file_list;
}

function delete_recursive($dir = "")
{
	$files = array_diff(scandir($dir), [".", ".."]);
	foreach ($files as $file) {
		is_dir("$dir/$file")
			? delete_recursive("$dir/$file")
			: unlink("$dir/$file");
	}
	return rmdir($dir);
}

function remove_old()
{
	global $backup_conf;

	// List to-be deleted files
	$cmd =
		"find " .
		$backup_conf['dst_dir'] .
		" -mtime +" .
		($backup_conf['retain'] - 1);
	debug(sprintf("\$mc = %s", $cmd));

	exec($cmd, $output, $retval);
	if ($retval == 0) {
		inform("Files to be deleted:");
		foreach ($output as $key => $value) {
			$md5_cmd = "md5sum $value | awk '{print $1}'";
			$du_cmd = "du -b $value | awk '{print $1}'";
			exec($md5_cmd, $md5, $retval);
			exec($du_cmd, $du, $retval);
			inform("$key: $value ($du[0] bytes, md5sum: $md5[0])");
		}
	}
	unset($output);

	$cmd =
		"find " .
		$backup_conf['dst_dir'] .
		" -mtime +" .
		$backup_conf['retain'] .
		" -delete";
	debug(sprintf("\$cmd = %s", $cmd));
	exec($cmd, $output, $retval);
	if ($retval == 0) {
		inform("Finished cleaning up " . $backup_conf['dst_dir'] . " ");
	} else {
		inform("Error $retval:");
		foreach ($output as $line) {
			inform("$line");
		}
	}

	return 0;
}

function backup_data()
{
	global $archive, $backup_data, $backup_conf, $files;
	global $class_archive;
	$search = "/var/log";
	$exclusions = [];

	// Adding files and folders to list of data to backup
	if (is_readable($backup_data['files'])) {
		$handle = fopen($backup_data['files'], "r");
		$fsize = filesize($backup_data['files']);
		while (($buffer = fgets($handle, $fsize)) !== false) {
			$afile = trim($buffer);
			// Verify the line is not commented out
			if (strpos($afile, "#") !== 0 and strlen($afile) > 0) {
				// Copy certain folders to tmp to prevent files from changing during tar
				if (strpos($afile, $search) === 0) {
					// Open files, copy to tmp dir for tar
					inform(sprintf("Copying %s to %s and adding it to list of files to backup", $afile, $backup_conf['tmp_dir']));
					$copied_files = copy_recursive(
						$afile,
						$backup_conf['tmp_dir']
					);
				} elseif (is_readable($afile)) {
					// Adding file/folder to list of backup
					inform("Adding $afile to list of files to backup");
					$class_archive->add_resource($afile);
					$files[] = $afile;
				} else {
					debug(sprintf("Not adding %s as it's not readable", $afile));
				}
			}
		}
		fclose($handle);
	}

	// Removing exclusions from list of data to backup
	if (is_readable($backup_data['files_skip'])) {
		$handle = fopen($backup_data['files_skip'], "r");
		$fsize = filesize($backup_data['files_skip']);
		while (($buffer = fgets($handle, $fsize)) !== false) {
			$exclusion = trim($buffer);
			// Verify the line is not commented out
			if (strpos($exclusion, "#") !== 0 and strlen($exclusion) > 0) {
				inform("Adding $exclusion to list of files to exclude");
				$class_archive->add_exclusion($exclusion);
				$exclusions[] = $exclusion;
			}
		}
		fclose($handle);
	}

	$archive =
		$backup_conf['dst_dir'] .
		"/" .
		$backup_conf['hostname'] .
		"-" .
		timestamp("Ymd");
	$class_archive->set_filename($archive);
	$class_archive->set_compression_method($backup_conf['compression']);
	$class_archive->set_split_size($backup_conf['split_size']);
	foreach (str_split($backup_conf['tar_options']) as $option) {
		$class_archive->add_tar_option($option);
	}
//	$archive .= $backup_data['archive_extension'];
//	inform("Creating archive $archive");
//
//	$cmd = $backup_data['archiver'];
//	$cmd .= " " . $backup_data['options'];
//	$cmd .= " " . $archive;
//
//	if (count($exclusions) > 0) {
//		foreach ($exclusions as $exclusion) {
//			$cmd .= " --exclude=$exclusion";
//		}
//	}
//
//	foreach ($files as $file) {
//		$cmd .= " $file";
//	}
//	$class_archive->write();
//
//	debug(sprintf("\$cmd = %s", $cmd));
//
//	exec($cmd, $output, $retval);
//	if ($retval != 0) {
//		inform("Error $retval:");
//		foreach ($output as $line) {
//			inform("$line");
//		}
//		die();
//	}
//	unset($output);
	if($class_archive->write()) {
		inform(sprintf("Wrote archive %s of size %d", $class_archive->get_filename(), $class_archive->get_size()));
	} else {
		exit("Unable to write archive or metafile\n");
	}

//
//	if ($backup_conf['pgp_encrypt']) {
//		encrypt();
//	}
//
//	$md5_cmd = "md5sum $archive | awk '{print $1}'";
//	$du_cmd = "du -b $archive | awk '{print $1}'";
//	exec($md5_cmd, $md5, $retval);
//	exec($du_cmd, $du, $retval);
//	inform("Finished creating $archive; size: $du[0]; md5sum: $md5[0]");
//
	foreach($class_archive->get_chunks() as $chunk) {
//		$chown_cmd = "chown {$backup_conf['luser']}:{$backup_conf['lgroup']} $chunk['filename']";
		$chown_cmd = sprintf("chown %s:%s %s", 
			$backup_conf['luser'],
			$backup_conf['lgroup'],
			$chunk['filename']
		);
		exec($chown_cmd, $output, $retval);
//		$chmod_cmd = "chmod 640 $chunk";
		$chmod_cmd = sprintf("chmod 640 %s", $chunk['filename']);
		exec($chmod_cmd, $output, $retval);
	}
//	$chown_cmd = "chown {$backup_conf['luser']}:{$backup_conf['lgroup']} $archive";
//	exec($chown_cmd, $output, $retval);
//	$chmod_cmd = "chmod 640 $archive";
//	exec($chmod_cmd, $output, $retval);
}

function store_remote()
{
	global $remote_host, $backup_conf;

	inform(sprintf("Storing archive to %s at %s using %s", $remote_host['address'], $remote_host['location'], $remote_host['method']));

	switch ($remote_host['method']) {
		case "scp":
			store_scp();
			break;
		case "ftp":
			store_ftp();
			break;
		case "rsync":
			store_rsync();
			break;
	}
}

function store_scp()
{
	global $archive, $remote_host, $backup_conf;

		$cmd = "sudo -u {$backup_conf['luser']} ";
	$cmd .= "scp $archive ";
	$cmd .=
		$remote_host['username'] .
		"@" .
		$remote_host['address'] .
		":" .
		$remote_host['location'];

	debug(sprintf("\$cmd = %s", $cmd));
	exec($cmd, $output, $retval);
	if ($retval == 0) {
		inform("Finished storing $archive");
	} else {
		inform("Error $retval:");
		foreach ($output as $line) {
			inform("$line");
		}
	}
}

function store_rsync()
{
	global $remote_host, $backup_conf;

	$cmd = "sudo -u {$backup_conf['luser']} ";
	$cmd .= "rsync " . $backup_conf['rsync_options'] . " ";
	$cmd .= $backup_conf['dst_dir'] . "/ ";
	$cmd .=
		$remote_host['username'] .
		"@" .
		$remote_host['address'] .
		":" .
		$remote_host['location'];

	debug(sprintf("\$cmd = %s", $cmd));

	$attempt = 0;
	while ($attempt < $backup_conf['store_retry']) {
		exec($cmd, $output, $retval);
		if ($retval == 0) {
			inform("Finished rsync");
			break;
		} else {
			inform(sprintf("Error %d on attempt %d of %d", $retval, $attempt +1, $backup_conf['store_retry'] +1));
			foreach ($output as $line) {
				inform("$line");
			}
			$attempt++;
		}
	}
}

function store_ftp()
{
	global $archive, $remote_host, $backup_conf, $backup_data;
	$old_archive =
		$remote_host['location'] .
		$backup_conf['hostname'] .
		"-" .
		timestamp("Ymd", strtotime("-" . $backup_conf['retain'] . " days")) .
		$backup_data['archive_extension'];

	($backup_conf['pgp_encrypt']) && $old_archive = sprintf("%s.gpg", $old_archive);
	debug(sprintf("\$old_archive: %s", $old_archive));
	$remote_file = $remote_host['location'] . basename($archive);

	$ftp_conn = ftp_connect($remote_host['address']);
	$login = ftp_login(
		$ftp_conn,
		$remote_host['username'],
		$remote_host['password']
	);

	if (ftp_delete($ftp_conn, $old_archive)) {
		inform(sprintf("Deleted %s from server"), $old_archive);
	} else {
		inform(sprintf("Unable to delete %s from server"), $old_archive);
	}

	if (ftp_put($ftp_conn, $remote_file, $archive, FTP_BINARY)) {
		inform("Finished storing $archive");
	} else {
		inform("Error storing to FTP");
	}
}

function timestamp($format = "Ymd-His", $time = 0)
{
	if ($time != 0) {
		return date($format, $time);
	} else {
		return date($format);
	}
}

function inform($msg, $newline = true)
{
	$output = sprintf("%s%s", $msg, $newline ? "\n" : "");
	echo $output;
}

function debug($msg)
{
	(DEBUG) ? $output = sprintf("DEBUG: %s | %s\n", date("H:i:s"), $msg) : $output = "";
	print $output;
}

function bash($cmd, &$stdout, &$stderr)
{
	$descriptorspec = [
		0 => ["pipe", "r"],  // stdin
		1 => ["pipe", "w"],  // stdout
		2 => ["pipe", "w"],  // stderr
	 ];

	 $process = proc_open($cmd, $descriptorspec, $pipes);

	 $stdout = stream_get_contents(($pipes[1]));
	 fclose($pipes[1]);

	 $stderr = stream_get_contents(($pipes[2]));
	 fclose($pipes[2]);

	 proc_close($process);
}

?>
